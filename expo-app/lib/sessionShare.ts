/**
 * Session Sharing Utility
 *
 * Handles exporting and sharing sessions as markdown or links.
 */

import * as Clipboard from 'expo-clipboard';
import * as Sharing from 'expo-sharing';
import { Platform } from 'react-native';
import { storage } from './offlineStorage';

// ============================================================================
// Types
// ============================================================================

export interface ShareableSession {
  id: string;
  title: string;
  repository?: string;
  createdAt: number;
  completedAt?: number;
  duration?: number;
  messageCount: number;
  tokenCount: number;
  messages: Array<{
    role: 'user' | 'assistant' | 'system';
    content: string;
    timestamp: number;
  }>;
  fileChanges?: Array<{
    path: string;
    type: 'created' | 'modified' | 'deleted';
  }>;
}

export type ShareFormat = 'markdown' | 'json' | 'text' | 'link';

export interface ShareOptions {
  format: ShareFormat;
  includeTimestamps?: boolean;
  includeFileChanges?: boolean;
  includeTokenCount?: boolean;
  anonymize?: boolean; // Remove sensitive data
}

// ============================================================================
// Constants
// ============================================================================

const DEFAULT_SHARE_OPTIONS: ShareOptions = {
  format: 'markdown',
  includeTimestamps: true,
  includeFileChanges: true,
  includeTokenCount: true,
  anonymize: false,
};

// ============================================================================
// Session Export Functions
// ============================================================================

/**
 * Convert a session to markdown format
 */
export function sessionToMarkdown(
  session: ShareableSession,
  options: ShareOptions = DEFAULT_SHARE_OPTIONS
): string {
  const lines: string[] = [];

  // Header
  lines.push(`# ${session.title}`);
  lines.push('');

  // Metadata
  if (session.repository) {
    lines.push(`**Repository:** ${session.repository}`);
  }
  lines.push(`**Created:** ${new Date(session.createdAt).toLocaleString()}`);
  if (session.completedAt) {
    lines.push(`**Completed:** ${new Date(session.completedAt).toLocaleString()}`);
  }
  if (session.duration) {
    lines.push(`**Duration:** ${Math.round(session.duration / 60)} minutes`);
  }
  if (options.includeTokenCount) {
    lines.push(`**Tokens:** ${session.tokenCount.toLocaleString()}`);
  }
  lines.push(`**Messages:** ${session.messageCount}`);
  lines.push('');

  // File changes
  if (options.includeFileChanges && session.fileChanges && session.fileChanges.length > 0) {
    lines.push('## File Changes');
    lines.push('');

    const grouped = session.fileChanges.reduce((acc, change) => {
      acc[change.type] = acc[change.type] || [];
      acc[change.type].push(change);
      return acc;
    }, {} as Record<string, typeof session.fileChanges>);

    for (const [type, changes] of Object.entries(grouped)) {
      lines.push(`### ${type.charAt(0).toUpperCase() + type.slice(1)}`);
      for (const change of changes) {
        lines.push(`- \`${change.path}\``);
      }
      lines.push('');
    }
  }

  // Messages
  lines.push('## Conversation');
  lines.push('');

  for (const message of session.messages) {
    if (message.role === 'system') continue;

    const name = message.role === 'user' ? 'User' : 'Assistant';
    lines.push(`### ${name}`);

    if (options.includeTimestamps) {
      lines.push(`*${new Date(message.timestamp).toLocaleString()}*`);
    }

    lines.push('');
    lines.push(message.content);
    lines.push('');
    lines.push('---');
    lines.push('');
  }

  // Footer
  lines.push('');
  lines.push('*Generated by Cloud Code*');

  return lines.join('\n');
}

/**
 * Convert a session to plain text format
 */
export function sessionToText(
  session: ShareableSession,
  options: ShareOptions = DEFAULT_SHARE_OPTIONS
): string {
  const lines: string[] = [];

  lines.push(session.title);
  lines.push('='.repeat(session.title.length));
  lines.push('');

  if (session.repository) {
    lines.push(`Repository: ${session.repository}`);
  }
  lines.push(`Created: ${new Date(session.createdAt).toLocaleString()}`);
  if (session.completedAt) {
    lines.push(`Completed: ${new Date(session.completedAt).toLocaleString()}`);
  }
  if (session.duration) {
    lines.push(`Duration: ${Math.round(session.duration / 60)} minutes`);
  }
  lines.push('');

  for (const message of session.messages) {
    if (message.role === 'system') continue;

    const name = message.role === 'user' ? 'USER:' : 'ASSISTANT:';
    lines.push(name);
    lines.push(message.content);
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Convert a session to JSON format
 */
export function sessionToJSON(
  session: ShareableSession,
  options: ShareOptions = DEFAULT_SHARE_OPTIONS
): string {
  const data: Record<string, unknown> = {
    id: session.id,
    title: session.title,
    repository: session.repository,
    createdAt: new Date(session.createdAt).toISOString(),
    completedAt: session.completedAt ? new Date(session.completedAt).toISOString() : undefined,
    duration: session.duration,
    messageCount: session.messageCount,
    tokenCount: session.tokenCount,
    messages: session.messages
      .filter((m) => m.role !== 'system')
      .map((msg) => ({
        role: msg.role,
        content: msg.content,
        timestamp: options.includeTimestamps ? new Date(msg.timestamp).toISOString() : undefined,
      })),
  };

  if (options.includeFileChanges && session.fileChanges) {
    data.fileChanges = session.fileChanges;
  }

  return JSON.stringify(data, null, 2);
}

/**
 * Generate a shareable link (for web, this would be a URL to the session)
 */
export function sessionToLink(session: ShareableSession): string {
  // For now, return a placeholder. In production, this would generate
  // a shareable URL to view the session on the web.
  const baseUrl = 'https://cloudcode.app/session';
  return `${baseUrl}/${session.id}`;
}

/**
 * Get the exported content for a session in the specified format
 */
export function exportSession(
  session: ShareableSession,
  format: ShareFormat = 'markdown',
  options?: Partial<ShareOptions>
): string {
  const fullOptions = { ...DEFAULT_SHARE_OPTIONS, ...options, format };

  switch (format) {
    case 'markdown':
      return sessionToMarkdown(session, fullOptions);
    case 'json':
      return sessionToJSON(session, fullOptions);
    case 'text':
      return sessionToText(session, fullOptions);
    case 'link':
      return sessionToLink(session);
    default:
      return sessionToMarkdown(session, fullOptions);
  }
}

// ============================================================================
// Sharing Functions
// ============================================================================

/**
 * Copy session to clipboard
 */
export async function copySessionToClipboard(
  session: ShareableSession,
  format: ShareFormat = 'markdown'
): Promise<void> {
  const content = exportSession(session, format);
  await Clipboard.setStringAsync(content);
}

/**
 * Share a session using the native share sheet
 */
export async function shareSession(
  session: ShareableSession,
  format: ShareFormat = 'markdown'
): Promise<void> {
  const content = exportSession(session, format);
  const filename = `${session.title.replace(/[^a-z0-9]/gi, '-').toLowerCase()}.${format === 'json' ? 'json' : 'md'}`;

  if (Platform.OS === 'web') {
    // On web, just copy to clipboard
    await copySessionToClipboard(session, format);
    return;
  }

  // On mobile, use the share sheet
  // Note: Sharing.shareAsync works with file:// URLs or direct content
  // For markdown, we'll create a temporary file
  try {
    await Sharing.shareAsync(content, {
      mimeType: format === 'json' ? 'application/json' : 'text/markdown',
      dialogTitle: `Share "${session.title}"`,
    });
  } catch (error) {
    // User cancelled or share failed
    console.log('[SessionShare] Share cancelled or failed:', error);
  }
}

/**
 * Load a session from storage for sharing
 */
export async function loadSessionForSharing(sessionId: string): Promise<ShareableSession | null> {
  try {
    const sessions = await storage.get<any[]>('chat_sessions') || [];
    const session = sessions.find((s) => s.id === sessionId);
    return session || null;
  } catch (error) {
    console.error('[SessionShare] Failed to load session:', error);
    return null;
  }
}

/**
 * Get a preview of the session (first few messages) for quick sharing
 */
export function getSessionPreview(session: ShareableSession, maxLength = 200): string {
  const preview = session.messages
    .filter((m) => m.role === 'assistant')
    .map((m) => m.content)
    .join('\n\n')
    .substring(0, maxLength);

  return preview + (preview.length >= maxLength ? '...' : '');
}

// ============================================================================
// Share Menu Options
// ============================================================================

export interface ShareMenuItem {
  id: string;
  label: string;
  icon: keyof typeof Ionicons.glyphMap;
  format: ShareFormat;
  action: (session: ShareableSession) => Promise<void>;
}

export const SHARE_MENU_ITEMS: ShareMenuItem[] = [
  {
    id: 'copy-md',
    label: 'Copy as Markdown',
    icon: 'document-text-outline',
    format: 'markdown',
    action: async (session) => copySessionToClipboard(session, 'markdown'),
  },
  {
    id: 'copy-json',
    label: 'Copy as JSON',
    icon: 'code-outline',
    format: 'json',
    action: async (session) => copySessionToClipboard(session, 'json'),
  },
  {
    id: 'copy-text',
    label: 'Copy as Text',
    icon: 'text-outline',
    format: 'text',
    action: async (session) => copySessionToClipboard(session, 'text'),
  },
  {
    id: 'share-link',
    label: 'Copy Link',
    icon: 'link-outline',
    format: 'link',
    action: async (session) => copySessionToClipboard(session, 'link'),
  },
  {
    id: 'share-file',
    label: 'Share File...',
    icon: 'share-outline',
    format: 'markdown',
    action: async (session) => shareSession(session, 'markdown'),
  },
];

// Import Ionicons for type reference
declare const Ionicons: { glyphMap: Record<string, string> };
